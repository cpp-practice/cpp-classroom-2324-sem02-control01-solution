= Контрольная I
:icons: font
:table-caption!:
:source-highlighter: highlightjs
:revealjs_hash: true
:customcss: https://gistcdn.githack.com/fedochet/4ee0f4a2224ecd29a961082a0c63c020/raw/18c107982aba90bb94194c0ac3a8a5ca9bad6782/asciidoc_revealjs_custom_style.css
:revealjs_theme: blood
:stylesheet: main.css
:toc:
:toclevels: 4

== Контрольная 1

* располагайте решение в namespace `control_01`, непубличные вещи — в подпространстве имен `details`
* нет отдельной задачи со звездочкой `[*]`, но есть возможность суммарно набрать 3.75 балла (100% очков — это 3 балла)
* к задаче 2 есть ncomp-тесты (проверяют некомпилируемость)
* _возможно, лучше решать в порядке: task02, task01_

== I. zip [2.75 балла]
Разработайте шаблонный класс `zip`, позволяющий итерироваться по набору нескольких контейнеров одновременно

=== Пример использования (попроще)

[source,cpp]
----
std::vector<size_t> x{1,2,3};
std::string str = "hello";

auto zipper = zip(x, str);  // zip<...>
auto it = zipper.begin();   // zip<...>::iterator (aka ZipIterator)

auto firstElements = *it;   // zip<...>::iterator::value_type (aka ZipTuple)

std::cout << firstElements.get<0>(); // 1
std::cout << firstElements.get<1>(); // 'h'
----

=== Базовая часть [1.5 балла]

ifdef::backend-revealjs[=== !]

Необходимые методы `zip`:

* конструкторы: от произвольного числа контейнеров, копирования
* `operator=`
** move-версии не нужны (zip не владеет переданными контейнерами)
* `begin`, `end` (const / non-const)
* `cbegin`, `cend`

ifdef::backend-revealjs[=== !]
Должны быть определены типы:

* `zip::iterator`
* `zip::const_iterator`

ifdef::backend-revealjs[=== !]
`zip::[const_]iterator` должен поддерживать

* `operator*`
* `operator++` (pre/post)
* `operator==`, `operator!=`
* `operator->`

ifdef::backend-revealjs[=== !]
Разыменованный итератор дает временный объект — `ZipTuple`:

* использует `std::tuple`, содержащий соответствующие элементы из всех контейнеров (ссылки, без владения)
* имеет дополнительный метод `get<size_t N>` для доступа к N-му элементу кортежа контейнеров

ifdef::backend-revealjs[=== !]
Также реализуйте вспомогательную функцию `make_zip` (поддержка вывода типа до С++17 и CTAD), принимающую на вход произвольноче число контейнеров и возвращающую сконструкированный от них `zip`


=== Пример использования идиоматический

[source,cpp]
----
std::vector<size_t> x{1,2,3};
std::string str = "hello";

// выведет
// 1; h
// 2; e
// 3; l
for (auto&& pair : zip(x, str)) {
  std::cout << pair.get<0>() << "; " << pair.get<1>() << std::endl;
}
----

=== zip end

Как видим по предыдущему примеру, переданные `zip` контейнеры могут быть разной длины. В таком случае, итерирование по `zip` должно останавливаться как только будет исчерпан контейнер с наименьшим числом элементов.

Послабление: считаем, что у каждого контейнера в zip есть метод `size()`,
тогда правильный `end()` можно построить в любой момент (возможно, дорого по времени)

ifdef::backend-revealjs[=== !]

NB: объект `zip` не должен получать контейнеры во владение. Ответственность пользователя — обеспечить время жизни контейнеров таким образом, чтобы `zip` имел валидные данные для итерирования, а также сохранение валидного состояния итераторов при итерировании с помощью zip

=== Указания

* В базовой части, для определения своего итератора стоит явно определить пропсы из https://en.cppreference.com/w/cpp/iterator/iterator_traits[`std::iterator_traits<MyIterator>`] — чтобы класс числился итератором
* В коде присутствует *сырая* заготовка классов — в каждом из них для описания 
внутреннего стейта достаточно использовать `std::tuple` над определенными элементами:
** `Zip` — знает про контейнеры; умеет порождать `begin()` и `end()`
** `ZipIterator` — знает про положение текущих итераторов, умеется сдвигаться и разыменовываться
** `ZipTuple` — знает про конкретные элементы контейнеров, умеет получать к ним доступ

=== Улучшения zip [1 балл]

* Поддержите возможность передачи констаных контейнеров в `zip`
* При условии, что все контейнеры поддерживают двунаправленное итерирование, поддержите:
** `operator--` (pre/post) у итераторов
** новый класс `zip::reverse_iterator` — чтобы итерироваться в обратном порядке

=== structured binding [0.25 балла]

Поддержите возможность использовать анпакинг специального вида:
[source,cpp]
----
std::vector<size_t> x{1,2,3};
std::string str = "hello";

for (auto&& [i, c] : zip(x, str)) {
  std::cout << i << "; " << c << std::endl;
}
----

Что для этого нужно — см. в https://en.cppreference.com/w/cpp/language/structured_binding#Case_2:_binding_a_tuple-like_type[binding a tuple-like type]


== II. Метапрограммирование [1 балл]

На Масленицу подают на стол тарелки с блинами и икрой

[source,cpp]
----
struct blin {};
struct ikra {};
template<class Sloy1, class... Sloi> struct tarelka {};
----

Блинов и икры может быть сколько угодно (не менее 1 слоя), но есть физическое ограничение: два слоя икры подряд сделать нельзя (это же получится один толстый слой).

=== Часть 1. Проверка правильности [0.5 балла]

Напишите метафункцию pravilno_v, которая проверяет, правильно ли сформировали стопку блинов и икры (нет двойной икры)

[source,cpp]
----
template<class Tarelka> constexpr bool pravilno_v = ???;
----

=== Часть 2. Конструктор тарелки [0.5 балла]

Напишите операцию сложения блинов и икры

[source,cpp]
----
auto bb = blin{} + blin{};  // tarelka<blin,blin>
auto bi = blin{} + ikra{};  // tarelka<blin,ikra>
auto bii = bi + ikra{};     // невозможно: две икры подряд!
auto ibi = ikra{} + bi;     // tarelka<ikra,blin,ikra>
auto ibi1 = ikra{} + blin{} + ikra{};  // tarelka<ikra,blin,ikra>
auto bibb = bi + bb;        // tarelka<blin,ikra,blin,blin>
auto biibi = bi + ibi;      // невозможно: две икры подряд
----

Ошибка двойной икры должна быть сделана как SFINAE (не найдётся перегрузка оператора), а не как безусловная ошибка компиляции (например, static_assert внутри). Это нужно для тестирования.

Обратите внимание, что из-за ассоциативности операции сложения операндами и слева и справа могут оказаться и отдельный блин или икра, и тарелки.
